## **의존성**

> 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우

- 실행 시점: 실행 시에 의존 대상객체가 반드시 존재
- 구현 시점: 의존 대상 객체가 변겨될 경우 의존하는 객체도 함께 변경

### 의존성 전이

> A가 B에 의존할경우 B가 의존하는 C에 자동으로 의존함

- 간접 의존성과 같음
- 의존의 대상은 객체일수도 있고 모듈이나 더 큰 규모의 실행 시스템 일 수도 있음
  - 중요한 것은 대상의 변경에 영향을 받을 수 있는 가능성

### 런타임, 컴파일 의존성

- 컴파일 의존성
  - 컴파일이 진행되는 시점: 객체
  - 코드를 작성하는 시점: 컴파일타임 의존성이 다루는 주제는 이 시점(클래스)
- 런타임 의존성
  - 클래스가 추상 클래스를 의존 할 경우 차이가 커짐
  - 즉 구현 클래스의 존재를 몰라도 구현 클래스와 협력할 수 있게 해주게 됨(컴파일 타임과의 차이점)
  -  컴파일 구조와 런타임 구조의 거리가 멀수록 설계가 유연해지고 재사용이 가능해짐
    - 협력 객체의 구체의 정보를 알수록 특정 문맥에 강하게 결합되기 때문
 
### 컨텍스트 독립성

> 클래스가 다른 구체 클래스에 대해 의존하는 것은 클래스의 인스턴스가 어떤 문맥(단위 기능)에서 사용될 것인지 명시하는 것

- 즉 특정한 문맥에 대해 최소한의 가정만으로 이루어져 잇다면 다른 문맥에서 사용하기 더 쉬워진다는 뜻
  - 이러한 것을 컨텍스트 독립성이라고 함

### 의존성 해결

> 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것

- 객체 생성자
- setter(가장 선호)
- 인자를 이용

## **유연한 설계**

> 유연하고 재사용 가능하게 만드는 것

- 바람직한 의존성: 다양한 환경에서 클래스를 재사용할 수 있도록 하는것
  - 즉 컨텍스트 독립적인 의존성
- 결합도: 바람직하지 않은 의존성
  - 느슨한 또는 약한 결합도(good)
  - 단단한 또는 강한 결합도(bad)
- 추상 클래스에 의존하면 느슨하게 결합됨

### 추상화

> 특정 절차나 물체를 의도적으로 생략하거나 감춤으로서 복잡도를 극복하는 방법

- 의존성
  - 구체 클래스 의존성: 높음
  - 추상 클래스 의존성: 중간
  - 인터페이스 의존성: 낮음
- 인터페이스에 의존하면 상속 계층을 모르더라도 협력이 가능
  - 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문
- 즉 의존하는 대상이 추상적일수록 결합도가 더 낮아짐

### 명시적 의존성

- 인스턴스 변수의 추상화만으로 부족
  - 클래스 내의 모든 의존성을 제거해야함
  - 따라서 의존성 해결이 필요한 상황이 필연적으로 생겨야 함
- 의존성 해결: 모든 의존성을 명시적으로 퍼블릭 인터페이스에 노출
  - 객체 생성자
  - setter(가장 선호)
  - 인자를 이용
- 클래스 내부에서 직접 생성하는 방식은 숨겨진 의존성이라고 함
  - 이것이 허용되는 것은 List와 같은 표준 클래스

### new

- new는 구체 클래스의 이름을 직접 기술해야하기 때문에 구체 클래스에 결합하게 된다.
- 어떤 인자를 사용해 생성자를 호출하는 지도 알아야 하기 때문에 더욱 결합도가 증가한다
- 하지만 편의성이 올라간다.(어떤 클래스를 주입해야 하는지에 대한 부분이 생략되므로)
  - 즉 가끔씩 다른 의존성이 사용되는 경우에 유용

### 컨텍스트 확장

- 코드 내부를 직접 수정하는 방식은 버그의 발생 가능성을 높임
  - 따라서 기존의 기능을 확장하여 협력 기능을 사용하는 것이 더욱 안전
- 이것이 가능한 이유는 추상화에 의존하고 생성자를 통해 의존성을 명시적으로 드러냈으며 new와 같이 구체클래스를 직접 다루어야하는 책임을 외부로 옮겼기 때문

### 결론

> 지식의 양이 결합도를 결정한다.

- 추상 클래스에 의해 공개되어야만 하는 기능에만 의존할 경우 지식의 양이 줄어들어 결합도가 줄어든다.
- 작은 객체들의 행동을 조합함으로서 새로운 행동을 이끌어낼 수 있는 것이 좋다.
- 그러면서 의존성 관리도 해야한다.
- 
